# Python面向对象
# 面向过程
# 面向过程编程（Procedural Programming）是一种以步骤和过程为核心的编程范式，其核心思想是将复杂问题分解为一系列可顺序执行的函数或过程，通过逐步调用来实现整体功能

# 核心思想
# 步骤分解：将问题拆解为多个子任务，每个子任务由独立的​​函数/过程​​实现。例如，处理学生早上的活动可分解为“起床→穿衣→洗漱→去学校”等步骤，每个步骤对应一个函数。
# 顺序执行​​：程序按代码的书写顺序从上到下执行，通过​​条件语句​​（如if）和​​循环结构​​（如for）控制流程
# 数据与操作分离​​：数据存储在全局或局部变量中，函数通过参数接收数据并处理，结果通过返回值或修改变量传递。
# 典型特征
# ​​- 模块化函数​​：功能封装为函数，例如计算两数之和的函数 add()，通过调用实现代码复用。

# ​​线性流程​​：程序逻辑清晰，易于调试。例如读取文件数据→处理数据→输出结果的流程。
# 高效性​​：适用于简单任务或对性能要求高的场景，因无需对象创建开销。
# 面向对象
# 面向对象编程（Object-Oriented Programming，OOP）是一种以​​对象​​为核心的编程范式，通过模拟现实世界中事物的交互逻辑来构建程序。其核心思想是将数据与操作数据的方法封装成独立的对象，通过对象之间的协作实现复杂功能

# 核心概念
# 类（Class）：定义对象的模板，描述一类事物的​​共性特征​​（如属性）和​​行为​​（如方法）。例如，"汽车"类包含属性"颜色"和方法"加速"。
# 对象（Object）：类的具体实例，拥有独立的​​状态​​（属性值）和​​行为​​。例如，一辆红色汽车是"汽车"类的对象
# 封装（Encapsulation）：将数据和方法捆绑在对象内部，仅通过暴露的接口与外界交互，保护数据安全并简化使用。例如，银行账户的余额只能通过特定方法修改。
# 继承（Inheritance）：子类可复用父类的属性和方法，并扩展新功能，实现代码复用和逻辑分层。例如，"电动车"类继承自"汽车"类，新增"充电"方法。
# 多态（Polymorphism）：同一方法在不同对象中呈现不同行为，增强代码灵活性。例如，"动物"类的"发声"方法在"狗"和"猫"对象中分别输出"汪汪"和"喵喵"。
# 抽象（Abstraction）：提取共性特征形成接口或抽象类，隐藏复杂实现细节，例如定义"图形"类的抽象方法"计算面积"。

# 核心优势：相对于函数式编程
# -​​可维护性​​：对象间低耦合，修改某部分代码不影响整体系统。​
# -​可扩展性​​：通过继承和多态灵活扩展功能，无需重写现有代码。​
# -​复用性​​：封装后的类可跨项目重复使用，减少冗余代码。​
# -​逻辑直观​​：以现实世界模型组织代码，更符合人类认知。
# 两者对比
# 面向过程—怎么做
# 把完成某一个需求的 所有步骤 从头到尾 逐步实现
# 根据开发需求，将某些功能独立的代码封装成一个又一个函数
# 最后完成的代码，就是顺序地调用不同的函数
# 注重步骤与过程，不注重职责和分工，如果需求比较复杂，虽然有函数封装，但是还是会导致代码比较臃肿。开发起来比较复杂。



# 面向对象—谁来做
# 相比较函数，面向对象是更大的封装，根据职责在一个对象中封装多个方法

# 在完成某一个需求前，首先确定职责 —— 要做的事情（方法）
# 根据职责确定不同的对象，在对象内部封装不同的方法（多个）
# 最后完成的代码，就是顺序地让不同的对象调用不同的方法
# 特点

# 注重对象和职责，不同的对象承担不同的职责。
# 更加适合应对复杂的需求变化，是专门应对复杂项目开发，提供的固定套路。
# 需要在面向过程基础上，再学习一些面向对象的语法。
# img-植物大战僵尸

# img-植物大战僵尸类

# 类与对象
# 在面向对象中，类与对象是两个核心的概念

# 类
# 类是对一群具有相同特征或者行为的事物的一个统称，是抽象的，不能直接使用
# 特征 被称为 属性
# 行为 被称为 方法
# 类就相当于制造飞机时的图纸，是一个模板，是负责创建对象的。
# img-飞机设计图纸

# 对象
# 对象是由类创建出来的一个具体存在，可以直接使用。
# 由哪一个类创建出来的对象，就拥有在哪一个类中定义的：属性 & 方法。
# 对象就相当于用图纸制造的飞机。
# img-飞机对象

# 类与对象的关系
# 类是模板，对象是根据类这个模板创建出来的，应该先有类，再有对象。
# 类只有一个，而对象可以有很多个：不同的对象之间属性可能会各不相同。
# 类中定义了什么属性和方法，对象中就有什么属性和方法，不可能多，也不可能少。
# 类的设计
# 在使用面相对象开发前，应该首先分析需求，确定一下，程序中需要包含哪些类

# img-植物大战僵尸类

# 在程序开发中，要设计一个类，通常需要满足一下三个要素：

# 类名 这类事物的名字，满足大驼峰命名法
# 属性 这类事物具有什么样的特征
# 方法 这类事物具有什么样的行为
# 大驼峰命名法

# CapWords
# 类名的确定

# 通常类名的选择，我们应该根据整个业务流程来提取，或者从大的角度来选择

# 属性和方法的确定

# 对对象的特征描述，通常可以定义成属性
# 对象具有的行为，通常可以定义成方法
# 类的定义
# 类的基本定于语法如下：

# class Human:
#     '''
#     这里可以写上对于这个类的说明
#     '''
#     变量 = xxxx    # 这里是类的静态属性，也可以理解为该类共有的特性
#     dic = {}
#     l1 = []
#     def __init__(self,xxx,xxx):        # 初始化方法
#         pass

#     def func(self):                    # 方法，动态属性
#         pass
# 示例：

# 定义一个人"类"，人类有思想，并且具备姓名，年龄，身高。人类还会吃饭，还会跑步等

# img-人类

# class Human(object):    # 默认继承自 object
#     """
#     此类用来构造人类
#     """
#     mind = "思考问题.."
#     def __init__(self,name,age,height):、
#         # 在__init__中，通过self给对象封装属性
#         self.name = name
#         self.age = age
#         self.height = height

#     def run(self):
#         print('高高兴兴的跑步')

#     def eat(self):
#         print('大口大口的吃饭')
# 这里的 object 和 self 的解释如下：

# object 是 Python 中所有类的基类。它是所有用户自定义类和内置类的顶层父类。可以理解为所有的类都继承自 object 类，所以才能具备类的初始化等许多基础特性。

# self 是一个约定俗成的参数名，用于引用类的实例。它代表当前对象的实例，使我们能够访问实例的属性和方法。

# 在实例方法中，第一个参数通常命名为 self，但你可以使用其他名称（虽然不推荐）。

# 实例化对象
# 通过类生成具体的对象的过程，我们称之为实例化。

# class Human(object):    # 默认继承自 object
#     """
#     此类用来构造人类
#     """
#     mind = "思考问题.."
#     def __init__(self,name,age,height):
#         self.name = name
#         self.age = age
#         self.height = height

#     def run(self):
#         print('高高兴兴的跑步')

#     def eat(self):
#         print('大口大口的吃饭')

# # 实例化对象
# xiaoming = Human('小明',18, 173.5)
# xiaohong = Human('小红',20, 165)
# 这里的小明和小红就是我们通过 Human 这个类实例化出来的具体的对象

# 其实实例化一个对象总共发生了三件事：

# 在内存中开辟了一个对象空间。
# 自动执行类中的 __init__ 方法，并将这个对象空间（内存地址）传给了 __init__ 方法的第一个位置参数 self。
# 在 __init__ 方法中通过 self 给对象空间添加属性。
# 对象访问类中的属性和方法

# # 访问静态属性
# print(xiaoming.mind)
# print(xiaohong.name)
# print(xiaohong.age)

# # 访问动态方法
# xiaohong.run()
# xiaoming.eat()
# 查看对象的所有属性

# 我们可以通过 object 基类中提供的 __dict__ 方法来查看某个对象的属性。

# # 通过对象查看类中所有的属性
# print(xiaoming.__dict__)
# 从类名的角度研究类
# 类名操作静态属性
# 查看类中所有的内容，用 类名.__dict__

# class Human(object):    # 默认继承自 object
#     """
#     此类用来构造人类
#     """
#     mind = "思考问题.."
#     # 在__init__中，通过self给对象封装属性
#     def __init__(self,name,age,height):

#         self.name = name
#         self.age = age
#         self.height = height

#     def run(self):
#         print('高高兴兴的跑步')

#     def eat(self):
#         print('大口大口的吃饭')

# print(Human.__dict__)
# print(Human.__dict__['mind'])
# Human.__dict__['mind'] = '高智慧'
# # 通过这种方式只能查询，不能增删改
# print(Human.__dict__)
# 万能的点 .

# 在面向对象中，我们更多的是使用 . 来获取类或者对象的属性或方法

# class Human(object):  # 默认继承自 object
#     """
#     此类用来构造人类
#     """
#     mind = "思考问题.."

#     def __init__(self, name, age, height):
#         # 在__init__中，通过self给对象封装属性
#         self.name = name
#         self.age = age
#         self.height = height

#     def run(self):
#         print('高高兴兴的跑步')

#     def eat(self):
#         print('大口大口的吃饭')


# print(Human.mind)
# Human.mind = '高智慧'
# print(Human.mind)

# del Human.mind
# Human.run = '慢慢悠悠的走路'
# print(Human.run)
# # 通过万能的点 可以增删改查类中的单个属性
# print('大口大口的吃饭')
# 总结：如果想要查看类的内容，我们可以使用__dict__方法，如果想要操作类中的某个属性，可以使用.

# 类名操作动态方法
# class Human(object):  # 默认继承自 object
#     """
#     此类用来构造人类
#     """
#     mind = "思考问题.."
#     # 在__init__中，通过self给对象封装属性
#     def __init__(self, name, age, height):
#         self.name = name
#         self.age = age
#         self.height = height

#     def run(self):
#         print(self,'高高兴兴的跑步')

#     def eat(self):
#         print(self,'大口大口的吃饭')

# # 可以直接通过human调用动态方法，也可以通过dict为类内部方法传递实参
# Human.eat('小明')
# Human.__dict__['run']('小红')
# 从对象的角度研究类
# 对象操作对象属性
# 对象也可以通过 __dict__ 查看对象的所有属性

# class Human(object):  # 默认继承自 object
#     """
#     此类用来构造人类
#     """
#     mind = "思考问题.."

#     def __init__(self, name, age, height):
#         self.name = name
#         self.age = age
#         self.height = height

#     def run(self):
#         print('高高兴兴的跑步')

#     def eat(self):
#         print('大口大口的吃饭')


# # 实例化出一个具体的对象
# xiaoming = Human('小明', 18, 173.5)
# xiaohong = Human('小红', 20, 165)

# print(xiaoming.__dict__)
# 同样也可以使用万能的点操作对象属性

# class Human(object):  # 默认继承自 object
#     """
#     此类用来构造人类
#     """
#     mind = "思考问题.."

#     def __init__(self, name, age, height):
#         self.name = name
#         self.age = age
#         self.height = height

#     def run(self):
#         print('高高兴兴的跑步')

#     def eat(self):
#         print('大口大口的吃饭')


# # 实例化出一个具体的对象
# xiaoming = Human('小明', 18, 173.5)
# xiaohong = Human('小红', 20, 165)

# # 修改属性
# xiaoming.name = "小小明"

# # 增加属性
# xiaoming.sex = "男"
# print(xiaoming.sex)

# # 删除属性
# del xiaoming.height

# # 查看属性
# print(xiaoming.__dict__)
# 对象查看类的属性
# class Human(object):  # 默认继承自 object
#     """
#     此类用来构造人类
#     """
#     mind = "思考问题.."

#     def __init__(self, name, age, height):
#         self.name = name
#         self.age = age
#         self.height = height

#     def run(self):
#         print('高高兴兴的跑步')

#     def eat(self):
#         print('大口大口的吃饭')


# # 实例化出一个具体的对象
# xiaoming = Human('小明', 18, 173.5)
# xiaohong = Human('小红', 20, 165)

# print(xiaoming.mind)
# 类的内置方法
# 方法名	作用
# __new__	创建对象时，会被自动调用
# __init__	对象被初始化时，会被自动调用
# __del__	对象被从内存中销毁前，会被自动调用
# __str__	返回对象的描述信息，print 函数输出使用
# __dir__	查看对象内所有属性以及方法
# 总结
# 现有类才有对象，类是模版，对象是通过类实例化出来的。
# 一个类可以实例化很多个对象。
# 类中包含静态属性和动态方法，包括内置方法，自定义方法。
# 实例化对象的时候，会自动调用 __init__ 来初始化，我们可以在 __init__ 中定义对象初始化的属性
# 实例化好的对象可以调用类中的方法或者是静态属性

